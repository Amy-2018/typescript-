## typescript入门

### 关于 TypeScript

 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持

##### TypeScript 的安装和编译

1.   tsc 编译

     npm i -g typescript 

     tsc -v
   
     tsc index.ts
   


2. nodemon编译 

   npm install -g nodemon  
   
   nodemon index.ts 
   

3. IDE自动编译



### 数据类型

- 布尔类型（boolean）

   取值只能是true、false
- 数字类型（number）

   数字类型, 整数/小数都包括, 同时支持2/8/10/16进制字面量.
- 字符串类型(string)
- 
- 数组类型（array）

    1).指定类型后面增加[] eg：number:[]
    
    2).泛型 Array[number]
- 元组类型（tuple）

    元组类型表示一个已知元素数量和类型的数组, 各元素的类型不必相同:
    
    let list4:[number, string] = [1, '2'];
- 枚举类型（enum）

   用于取值被限定在一定范围内的场景，比如一周只能有七天
   
   编译后会被转化成对象, 默认元素的值从0开始，也可以手动设置值
   
   根据枚举类型值的类型可分为如下几种：
   
   - 数字枚举  
   
   - 字符串枚举
   
   - 异构枚举 
     
       数字枚举、字符串枚举混用，不建议使用
       
   - 常数枚举  const enum 
       
        1） 与普通枚举的区别是，成员变量它会在编译阶段被删除
        
        2） 成员变量的值不能是可计算的，会报错
       
       
   ##### 枚举成员
    
      - 成员的值是可读的，不能修改的
      
      - 成员变量的值是常数项和计算所得项
      
        当一个表达式满足下面条件之一时，它就是一个常量枚举表达式
         - 一个枚举表达式字面量（主要是字符串字面量或数字字面量）
         - 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）
         - 带括号的常量枚举表达式
         - 一元运算符 +, -, ~其中之一应用在了常量枚举表达式
         - 常量枚举表达式做为二元运算符 +, -, *, /, %, <<, >>, >>>, &, |, ^的操作对象。 若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。
        
        
   
- 任意类型（any）

   1.接入第三方库
   
   2.初学前期
   
- null 和 undefined 

   当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自
   null、undefined是任何类型的子类型
   
- void类型 

   一般用来标记函数没有返回值
   
   这时候就不能写return了
   
- never类型 

    . throw new Error(message)
    
    . return error("Something failed")
    
    . while (true) {} // 存在无法达到的终点
    
- 联合类型 |  

     联合类型也是将多个类型合并为一个类型, 表示"或"的关系,用|连接多个类型
     
- 交叉类型 &  

    交叉类型是将多个类型合并为一个类型, 表示"并且"的关系,用&连接多个类型, 常用于对象合并
    
- 类型断言 手动指定一个值的类型  

    语法：<类型>值 或 值 as 类型
    
    注： 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的
    
 -  类型推论 
 
     如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。
 
-  类型别名 type 
 
     使用 type 创建类型别名,类型别名常用于联合类型
  
-  对象类型 object 
 
     一般不用，他标注不具体，一般用接口
 
- unknown 
     
      unknown 类型不能赋值给除了 unknown 或 any 的其他任何类型，使用前必需显式进行指定类型，或是在有条件判断情况下能够隐式地进行类型推断的情况。如果没有使用类型断言，则几乎没有可赋的值。你也不能访问 unknown 的任何属性，或者调用 / 构建它们。
      
      使用场景： unknown 用于变量类型不确定，但肯定可以确定的情形下
      
      - 与正交类型的搭配
      
        正交类型（intersection type）中，unknown 不起作用：
        
      - 与联合类型的搭配
      
         联合类型（union type）中 unknown 起绝对作用：

     
 -  接口 interface
 
     - 它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。
     
     - 字段个数、类型必须一致
     
     - 非必填(?) 
     
     - 只读属性 readonly 只读的约束存在于第一次给对象赋值的时候
     
     - 顺序： 只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后 
     
     - 任意属性 一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性
     
     - 对于从服务器端获取或者业务场景中模拟的数据（数据通常不经常变化和调整的），或者ui文本
     
     - 接口只能约束类的共有成员
     
      
       ```
       interface iProps {
 
         readonly x: number;
 
         readonly y: number;
         
         name: string;
         
         age: number;
         
         height?: number;
         
         [propName: string]: any;
       }
       ```

### 函数

#### 函数定义法

1. 函数声明法
2. 匿名函数

#### 定义方法传参

1. 固定参数
2. 可选参数
3. 默认参数
4. 剩余参数 rest
注： 可选参数、默认参数、rest都要放到最后

#### 函数重载

重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。

### 类

#### 修饰符

public 默认

private 在类里面可以访问，在子类、类外部不能访问

protected 在类里面子类里面可以访问，在类外部不能访问

public > protected > private

#### 特性

1. 静态属性

2. 静态方法

3. 多态 
   父类定义一个方法不去实现，让继承它的子类去实现，每一个子类有不同表现

4. 抽象类 
   它是提供其他类继承的基类，不能直接被实例化
   abstract抽象方法只能在抽象类中
   子类必须实现抽象方法


### 泛型
    解决类、接口、方法的复用、以及对不特定数据类型的支持
    
    







